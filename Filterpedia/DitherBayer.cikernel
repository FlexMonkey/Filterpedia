//
//  DitherBayer.cikernel
//  Filterpedia
//
//  Created by African Swift on 09/02/2016.
//  Copyright Â© 2016 Simon Gladman. All rights reserved.
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>
//
//
// Ordered Dithering:
//      Non Diffusion Dithering (i.e. specifically no diffusion of errors).
//
// Algorithm:
//      Bayer Matrix (2x2, 3x3, 4x4 and 8x8)
//
// Reference:
//      https://en.wikipedia.org/wiki/Ordered_dithering
//
// Color Palettes:
//      1) Binary:     Black 0x00 and white 0xFF using only the red component.
//      2) 3 Bit RGB:  All three components converted to either 0x00 or 0xFF.
//
// Current Limitations:
//      1) Palette limitation (see above)
//      2) Transparency pixels not specifically excluded, however alpha values are unaltered.


float orderedDither2x2(float colorin, float bx, float by, float errorIntensity)
{
    float error = 0.0;
    int px = int(bx);
    int py = int(by);
    if (py == 0) {
        if (px == 0) { error = 1.0 / 5.0; }
        if (px == 1) { error = 3.0 / 5.0; }
    }
    if (py == 1) {
        if (px == 0) { error = 4.0 / 5.0; }
        if (px == 1) { error = 2.0 / 5.0; }
    }
    return colorin * (error * 2.0 * errorIntensity + (1.0 - errorIntensity)) > 0.5 ? 1.0 : 0.0;
}

float orderedDither3x3(float colorin, float bx, float by, float errorIntensity)
{
    float error = 0.0;
    int px = int(bx);
    int py = int(by);
    if (py == 0) {
        if (px == 0) { error = 3.0 / 10.0; }
        if (px == 1) { error = 7.0 / 10.0; }
        if (px == 2) { error = 4.0 / 10.0; }
    }
    if (py == 1) {
        if (px == 0) { error = 6.0 / 10.0; }
        if (px == 1) { error = 1.0 / 10.0; }
        if (px == 2) { error = 9.0 / 10.0; }
    }
    if (py == 2) {
        if (px == 0) { error = 2.0 / 10.0; }
        if (px == 1) { error = 8.0 / 10.0; }
        if (px == 2) { error = 5.0 / 10.0; }
    }
    return colorin * (error * 2.0 * errorIntensity + (1.0 - errorIntensity)) > 0.5 ? 1.0 : 0.0;
}

float orderedDither4x4(float colorin, float bx, float by, float errorIntensity)
{
    float error = 0.0;
    int px = int(bx);
    int py = int(by);
    if (py == 0) {
        if (px == 0) { error = 1.0 / 17.0; }
        if (px == 1) { error = 9.0 / 17.0; }
        if (px == 2) { error = 3.0 / 17.0; }
        if (px == 3) { error = 11.0 / 17.0; }
    }
    if (py == 1) {
        if (px == 0) { error = 13.0 / 17.0; }
        if (px == 1) { error = 5.0 / 17.0; }
        if (px == 2) { error = 15.0 / 17.0; }
        if (px == 3) { error = 7.0 / 17.0; }
    }
    if (py == 2) {
        if (px == 0) { error = 4.0 / 17.0; }
        if (px == 1) { error = 12.0 / 17.0; }
        if (px == 2) { error = 2.0 / 17.0; }
        if (px == 3) { error = 10.0 / 17.0; }
    }
    if (py == 3) {
        if (px == 0) { error = 16.0 / 17.0; }
        if (px == 1) { error = 8.0 / 17.0; }
        if (px == 2) { error = 14.0 / 17.0; }
        if (px == 3) { error = 6.0 / 17.0; }
    }
return colorin * (error * 2.0 * errorIntensity + (1.0 - errorIntensity)) > 0.5 ? 1.0 : 0.0;
}

float orderedDither8x8(float colorin, float bx, float by, float errorIntensity)
{
    float error = 0.0;
    int px = int(bx);
    int py = int(by);
    if (py == 0) {
        if (px == 0) { error =  1.0 / 65.0; }
        if (px == 1) { error = 49.0 / 65.0; }
        if (px == 2) { error = 13.0 / 65.0; }
        if (px == 3) { error = 61.0 / 65.0; }
        if (px == 4) { error =  4.0 / 65.0; }
        if (px == 5) { error = 52.0 / 65.0; }
        if (px == 6) { error = 16.0 / 65.0; }
        if (px == 7) { error = 64.0 / 65.0; }
    }
    if (py == 1) {
        if (px == 0) { error = 33.0 / 65.0; }
        if (px == 1) { error = 17.0 / 65.0; }
        if (px == 2) { error = 45.0 / 65.0; }
        if (px == 3) { error = 29.0 / 65.0; }
        if (px == 4) { error = 36.0 / 65.0; }
        if (px == 5) { error = 20.0 / 65.0; }
        if (px == 6) { error = 48.0 / 65.0; }
        if (px == 7) { error = 32.0 / 65.0; }
    }
    if (py == 2) {
        if (px == 0) { error =  9.0 / 65.0; }
        if (px == 1) { error = 57.0 / 65.0; }
        if (px == 2) { error =  5.0 / 65.0; }
        if (px == 3) { error = 53.0 / 65.0; }
        if (px == 4) { error = 12.0 / 65.0; }
        if (px == 5) { error = 60.0 / 65.0; }
        if (px == 6) { error =  8.0 / 65.0; }
        if (px == 7) { error = 56.0 / 65.0; }
    }
    if (py == 3) {
        if (px == 0) { error = 41.0 / 65.0; }
        if (px == 1) { error = 25.0 / 65.0; }
        if (px == 2) { error = 37.0 / 65.0; }
        if (px == 3) { error = 21.0 / 65.0; }
        if (px == 4) { error = 44.0 / 65.0; }
        if (px == 5) { error = 28.0 / 65.0; }
        if (px == 6) { error = 40.0 / 65.0; }
        if (px == 7) { error = 24.0 / 65.0; }
    }
    if (py == 4) {
        if (px == 0) { error =  3.0 / 65.0; }
        if (px == 1) { error = 51.0 / 65.0; }
        if (px == 2) { error = 15.0 / 65.0; }
        if (px == 3) { error = 63.0 / 65.0; }
        if (px == 4) { error =  2.0 / 65.0; }
        if (px == 5) { error = 50.0 / 65.0; }
        if (px == 6) { error = 14.0 / 65.0; }
        if (px == 7) { error = 62.0 / 65.0; }
    }
    if (py == 5) {
        if (px == 0) { error = 35.0 / 65.0; }
        if (px == 1) { error = 19.0 / 65.0; }
        if (px == 2) { error = 47.0 / 65.0; }
        if (px == 3) { error = 31.0 / 65.0; }
        if (px == 4) { error = 34.0 / 65.0; }
        if (px == 5) { error = 18.0 / 65.0; }
        if (px == 6) { error = 46.0 / 65.0; }
        if (px == 7) { error = 30.0 / 65.0; }
    }
    if (py == 6) {
        if (px == 0) { error = 11.0 / 65.0; }
        if (px == 1) { error = 59.0 / 65.0; }
        if (px == 2) { error =  7.0 / 65.0; }
        if (px == 3) { error = 55.0 / 65.0; }
        if (px == 4) { error = 10.0 / 65.0; }
        if (px == 5) { error = 58.0 / 65.0; }
        if (px == 6) { error =  6.0 / 65.0; }
        if (px == 7) { error = 54.0 / 65.0; }
    }
    if (py == 7) {
        if (px == 0) { error = 43.0 / 65.0; }
        if (px == 1) { error = 27.0 / 65.0; }
        if (px == 2) { error = 39.0 / 65.0; }
        if (px == 3) { error = 23.0 / 65.0; }
        if (px == 4) { error = 42.0 / 65.0; }
        if (px == 5) { error = 26.0 / 65.0; }
        if (px == 6) { error = 38.0 / 65.0; }
        if (px == 7) { error = 22.0 / 65.0; }
    }
    return colorin * (error * 2.0 * errorIntensity + (1.0 - errorIntensity)) > 0.5 ? 1.0 : 0.0;
}

kernel vec4 ditherBayer(__sample image, float intensity, float matrix, float palette)
{
    vec4 pixel = sample(image, samplerCoord(image));
    float px = mod(samplerCoord(image).x, 4.0);
    float py = mod(samplerCoord(image).y, 4.0);

    float red = palette < 1.0 ? pixel.r : pixel.r;
    float green = palette < 1.0 ? pixel.r : pixel.g;
    float blue = palette < 1.0 ? pixel.r : pixel.b;

    if (matrix >= 2.0 && matrix < 3.0) {
        pixel.r = orderedDither2x2(red, px, py, intensity);
        pixel.g = orderedDither2x2(green, px, py, intensity);
        pixel.b = orderedDither2x2(blue, px, py, intensity);
    }

    if (matrix >= 3.0 && matrix < 4.0) {
        pixel.r = orderedDither3x3(red, px, py, intensity);
        pixel.g = orderedDither3x3(green, px, py, intensity);
        pixel.b = orderedDither3x3(blue, px, py, intensity);
    }

    if (matrix >= 4.0 && matrix < 5.0) {
        pixel.r = orderedDither4x4(red, px, py, intensity);
        pixel.g = orderedDither4x4(green, px, py, intensity);
        pixel.b = orderedDither4x4(blue, px, py, intensity);
    }
    if (matrix > 5.0) {
        pixel.r = orderedDither8x8(red, px, py, intensity);
        pixel.g = orderedDither8x8(green, px, py, intensity);
        pixel.b = orderedDither8x8(blue, px, py, intensity);
    }
    return pixel;
}